\declaremodule{extension}{pygsl.init}
\moduleauthor{Pierre Schnizer}{schnizer@users.sourceforge.net}
\moduleauthor{Achim G\"adke}{achimgaedke@users.sourceforge.net}

This module is called the first time when loading \module{pygsl}.
All following procedures are called once and before everything other.

\section{Exception handling}
\index{exception handling!initialisation} GSL provides a selectable error
handler, that is called for occuring errors (like domain errors, division by
zero, etc. ).  \module{pygsl.init} installs a handler by calling
\cfunction{gsl_set_error_handler} to set an appropiate exception from
\module{pygsl.errors}.  A \module{pygsl} interface function should return
\code{NULL} in case of an error, so the exception is raised.  If this handler
is called more than once before returning to python, only the first set
exception is raised.

Here is a python level example:
\begin{verbatim}
import pygsl.histogram
import pygsl.errors
hist=pygsl.histogram.histogram2d(100,100)
try:
   hist[-1,-1]=0
except pygsl.errors.gsl_Error,err:
   print err
\end{verbatim}
Will result
\begin{verbatim}
input domain error: index i lies outside valid range of 0 .. nx - 1
\end{verbatim}

\section{IEEE-mode}
\index{ieee-mode!initialisation}
The IEEE mode is set from the environment variable \envvar{GSL_IEEE_MODE} via \cfunction{gsl_ieee_env_setup()}.
After the initialisation use \module{pygsl.ieee} for manipulation.

\section{random number generators}
\index{random number generator!initialisation}
Also the random number generator can be initialised from the environment variables \envvar{GSL_RNG_TYPE}
and \envvar{GSL_RNG_SEED} using the gsl function \cfunction{gsl_rng_env_setup()}.
Each random number generators are initialised with \envvar{GSL_RNG_SEED}.

The default generator can be created by:\nopagebreak
\begin{verbatim}
import pygsl.rng
my_rng=gsl_rng()
print my_rng.name()
\end{verbatim}

\section{Debugging adding infrastructure}

If you look into the  file ``setup.py'', you will spot
\begin{verbatim}
macros = macros + [('DEBUG', 1)]
\end{verbatim}

This will define DEBUG=1 for the preprocessor.

PyGSL comes with the following macros, which are shallow warppers around
 fprintf (see also Include/pygsl/intern.h Lines 120-127 and
Include/pygsl/utils.h)

\cfunction{FUNC_MESS_BEGIN()}
\cfunction{FUNC_MESS_END()}
\cfunction{DEBUG_MESS(level, mess, ...)}

All these use PyGSL_DEBUG_LEVEL() to see if the status should be printed. This goes
back  either to a value defined at compile time, if set to bigger than 0.
If DEBUG is not defined at compile time, all this information will be
left out.

DEBUG=1 is special. In this case, PyGSL_DEBUG_LEVEL() is a static
defined variable. Depending on the value of this variable (which is
unique to each module implemented in C) the above mentioned macros will
print out the information.

The memory location of this variable is registered by init_pygsl() (see
also Include/pygsl/intern.h Lines 135--) via PyGSL_init_debug()
to PyGSL_register_debug_flag which is implemented in
src/init/initmodule.c. This keeps a Python lists of CObjects which hold
pointers to the memory locations of the variables pygsl_debug_level.

If one calls pygsl.init.set_debug_level(level), it will set the values
of all these variables and one can see the aforementioned prints.