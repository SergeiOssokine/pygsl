/* -*- C -*- */
/**
 * Author: Pierre Schnizer		
 */
#include <typemaps/pygsl_profile.h>
#include <utils/util.h>
/*
 *  These macros convert a PyObect to  a complex if numeric 
 *  Input recieved. If complex, accessing the data, otherwise
 *  reverting to a function.
 */
#define PyGSL_PyCOMPLEX_TO_gsl_complex(object, tmp)            \
(PyComplex_Check(object)) ? 				       \
     (tmp)->dat[0] = ((PyComplexObject *) object)->cval.real,  \
     (tmp)->dat[1] = ((PyComplexObject *) object)->cval.imag,  \
     GSL_SUCCESS 					       \
     : PyGSL_PyComplex_to_gsl_complex(object, tmp)         

#define PyGSL_PyCOMPLEX_TO_gsl_complex_float(object, tmp )     \
(PyComplex_Check(object)) ?                                    \
     (tmp)->dat[0] = ((PyComplexObject *) object)->cval.real,  \
     (tmp)->dat[1] = ((PyComplexObject *) object)->cval.imag,  \
     GSL_SUCCESS                                               \
     : PyGSL_PyComplex_to_gsl_complex_float(object, tmp)      

#define PyGSL_PyCOMPLEX_TO_gsl_complex_long_double(object, tmp ) \
(PyComplex_Check(object)) ?                                      \
     (tmp)->dat[0] = ((PyComplexObject *) object)->cval.real,    \
     (tmp)->dat[1] = ((PyComplexObject *) object)->cval.imag,    \
     GSL_SUCCESS                                                 \
     : PyGSL_PyComplex_to_gsl_complex_long_double(object, tmp)
/* -------------------------------------------------------------------------
   Helper Functions
   ------------------------------------------------------------------------- */
static int
PyGSL_PyComplex_to_gsl_complex(PyObject * src, gsl_complex * mycomplex){
     PyObject * fitem;

     FUNC_MESS_BEGIN();
    /* 
     * This function is only called if the straight one did not succed.
     */
     
     /*
     * As it was not a complex (or a complex array element) I try to get a 
     * float.
     */

     fitem = PyNumber_Float(src);
     if(!fitem){
	  PyErr_SetString(PyExc_TypeError, 
			  "I could not convert the input to complex or float!"\
			  "Was the input numeric?\n");
	  return GSL_FAILURE;
     }
     PyGSL_INCREASE_complex_transform_counter();

     mycomplex->dat[0] = PyFloat_AS_DOUBLE(fitem);
     mycomplex->dat[1] = 0;
     Py_DECREF(fitem);
     FUNC_MESS_END();
     return GSL_SUCCESS;

}
static int
PyGSL_PyComplex_to_gsl_complex_float(PyObject * src, 
				     gsl_complex_float * mycomplex){
     PyObject * fitem;
     FUNC_MESS_BEGIN();
     fitem = PyNumber_Float(src);
     if(!fitem){
	  PyErr_SetString(PyExc_TypeError, 
			  "I could not convert the input to complex or float!"\
			  "Was the input numeric?\n");
	  return GSL_FAILURE;
     }
     PyGSL_INCREASE_complex_transform_counter();
     mycomplex->dat[0] = PyFloat_AS_DOUBLE(fitem);
     mycomplex->dat[1] = 0;
     Py_DECREF(fitem);
     FUNC_MESS_END();
     return GSL_SUCCESS;
}
 
static int 
PyGSL_PyComplex_to_gsl_complex_long_double(PyObject * src, 
					   gsl_complex_long_double * mycomplex){

     PyObject * fitem;
     FUNC_MESS_BEGIN();
     fitem = PyNumber_Float(src);
     if(!fitem){
	  PyErr_SetString(PyExc_TypeError, 
			  "I could not convert the input to complex or float!"\
			  " Was the input numeric?\n");
	  return GSL_FAILURE;
     }
     PyGSL_INCREASE_complex_transform_counter();
     mycomplex->dat[0] = PyFloat_AS_DOUBLE(fitem);
     mycomplex->dat[1] = 0;
     FUNC_MESS_END();
     return GSL_SUCCESS;
}
