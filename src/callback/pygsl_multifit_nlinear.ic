/* -*- C -*- */
#include "pygsl_multifit_nlinear.h"
#include <Python.h>

/*
 * callbacks f and df are quite the same code for a large extend
 */
static int
_PyGSL_multifit_nlinear_callback_obj(PyObject * callback, const gsl_vector * x,
				     pygsl_multifit_nlinear_params * t_params, PyObject **ob)
{
	PyArrayObject *x_array = NULL;
	PyObject *object=NULL, *args = NULL, *stat_o = NULL, *ret = NULL;
	PyGSL_error_info  info;
	int status = GSL_EINVAL, flag = GSL_EFAILED;
	
	assert(ob != NULL);
	*ob = NULL;
	/* the line number to appear in the traceback */ 
	int trb_lineno = -1;
	FUNC_MESS_BEGIN();    

	assert(t_params != NULL);
     
	/* Do I need to copy the array ??? */
	x_array = PyGSL_copy_gslvector_to_pyarray(x);
	if (x_array == NULL){
		trb_lineno = __LINE__ - 2;
		goto fail;
	}

	args = t_params->args;
	Py_XINCREF(args);
	/*  XXX required ? arsg can be NULL
	    assert(args != NULL);
	*/
	DEBUG_MESS(2, "callback (f|df) = %p, x_array  = %p, args = %p",
		   callback, x_array, args);

	assert(callback != NULL);
	FUNC_MESS("    Call Python Object BEGIN");
	ret = PyObject_CallFunctionObjArgs(callback, x_array, args, NULL);
	x_array = NULL;
	args = NULL;
	FUNC_MESS("    Call Python Object END");

	info.callback = callback;
	info.message  = __FUNCTION__;
	info.error_description = NULL;
	info.argnum = 0;
	if(PyGSL_CHECK_PYTHON_RETURN(ret, 2, &info) != GSL_SUCCESS){
		trb_lineno = __LINE__ - 1;
		status = PyGSL_ANY;
		goto fail;
	}

	stat_o = PyTuple_GET_ITEM(ret, 0);
	if (stat_o == NULL){
		trb_lineno = __LINE__ - 2;
		status = PyGSL_ANY;
		goto fail;
	}

	info.argnum = 1;
	trb_lineno = __LINE__ + 1;
	flag = PyGSL_pyint_to_int(stat_o, &status, &info);
	/* 
	 * what are the flags that should be returned to to GSL ?
	 * an exception would have returned NULL and would not end up here 
	 */
	switch(flag){		
	case GSL_SUCCESS:
		break;
	default:
		status = flag;
		goto fail;
	}
	
	object = PyTuple_GET_ITEM(ret, 1);
	if (object == NULL){
		trb_lineno = __LINE__ - 2;
		status = PyGSL_ANY;
		goto fail;
	}
	
	Py_INCREF(object); /* part of the return tuple */
	Py_DECREF(ret);
	ret = NULL;
	*ob = object;
	return status;
     
  fail:
	PyGSL_add_traceback(NULL, __FILE__, __FUNCTION__, trb_lineno);
	FUNC_MESS("Failure");
	/* Py_XDECREF(args); */
	Py_XDECREF(ret);
	Py_XDECREF(x_array);
	/* Py_XDECREF(object); */
	return status;
}
/* 1. A_n O -> A_p  */
static int
PyGSL_multifit_nlinear_callback_f(const gsl_vector * x, void * param, gsl_vector *f)
{
	PyObject *object=NULL, *callback = NULL;
	PyGSL_error_info  info;
	pygsl_multifit_nlinear_params * t_params;
	int status = GSL_EFAILED, trb_lineno = __LINE__;

	FUNC_MESS_BEGIN();    

	assert(param != NULL);
	t_params = (pygsl_multifit_nlinear_params *) param;
	callback = t_params->f;
	
	status = _PyGSL_multifit_nlinear_callback_obj(callback, x, param, &object);
	switch(status){
	case GSL_SUCCESS:
		break;
	default:
		trb_lineno = __LINE__ - 5;
		goto fail;
	}
	
	info.callback = callback;
	info.message  = __FUNCTION__;
	info.error_description = NULL;
	info.argnum = 1;
	if(PyGSL_copy_pyarray_to_gslvector(f, object, f->size, &info) != GSL_SUCCESS){
		trb_lineno = __LINE__ - 1;
		status = PyGSL_ANY;
		goto fail;
	}     
	Py_DECREF(object);
	object = NULL;
	FUNC_MESS_END();
	return status;
	
  fail:
	PyGSL_add_traceback(NULL, __FILE__, __FUNCTION__, trb_lineno);
	FUNC_MESS("Failure");
	Py_XDECREF(object);
	return status;
}

static int
PyGSL_multifit_nlinear_callback_df(const gsl_vector * x, void * param, gsl_matrix *J)
{
	PyObject *object=NULL, * callback = NULL;
	pygsl_multifit_nlinear_params * t_params;
	PyGSL_error_info  info;
	int status = GSL_EFAILED, status2 = GSL_EFAILED, trb_lineno = __LINE__;

	FUNC_MESS_BEGIN();
	
	assert(param != NULL);
	t_params = (pygsl_multifit_nlinear_params *) param;
	callback = t_params->df;

	status = _PyGSL_multifit_nlinear_callback_obj(callback, x, param, &object);
	switch(status){
	case GSL_SUCCESS:
		break;
	default:
		trb_lineno = __LINE__ - 5;
		goto fail;
	}
	
	info.callback = callback;
	info.message  = __FUNCTION__;
	info.error_description = NULL;
	info.argnum = 1;
	status2 = PyGSL_copy_pyarray_to_gslmatrix(J, object, J->size1, J->size2, &info);
	if(status2 != GSL_SUCCESS){
		trb_lineno = __LINE__ - 1;
		status = status2;
		goto fail;
	}     
	Py_DECREF(object);
	gsl_matrix_get(J, 0, 0);
	if (J->size1 >= 2 && J->size2 >= 2){
		DEBUG_MESS(2, "\t J[0, 0] = %g\t J[0, 1] =%g\n"
			   "\t\t J[1, 0] = %g\t J[1, 1] =%g",
			   gsl_matrix_get(J, 0, 0),  gsl_matrix_get(J, 0, 1),
			   gsl_matrix_get(J, 1, 0),  gsl_matrix_get(J, 1, 1)
			   );
	}
	object = NULL;
	FUNC_MESS_END();
	return status;
     
 fail:
	PyGSL_add_traceback(NULL, __FILE__, __FUNCTION__, trb_lineno);
	FUNC_MESS("Failure");
	Py_XDECREF(object);
	return status;
}

static int
pygsl_multifit_nlinear_callback_fvv(const gsl_vector * x, const gsl_vector * v,
				    void * params, gsl_vector * fvv)
{
	PyObject * callback = NULL, *args = NULL, *object = NULL,
		*stat_o = NULL, *ret = NULL;
	PyArrayObject *x_array = NULL, *v_array = NULL;
	
	pygsl_multifit_nlinear_params *t_params;
	PyGSL_error_info  info;
	int status = GSL_EFAILED, flag = GSL_EFAILED, line = __LINE__;

	FUNC_MESS_BEGIN();
	assert(params != NULL);
	t_params = (pygsl_multifit_nlinear_params *) params;
    
	callback = t_params->fvv;
	if(callback == NULL){
		line = __LINE__ - 1;
		status =  GSL_EINVAL;
		gsl_error("Function call unexpected. No python callback found",
			  __FILE__, line, status);
	}

	x_array = PyGSL_copy_gslvector_to_pyarray(x);
	if (x_array == NULL){
		line = __LINE__ - 2;
		status = PyGSL_ANY;
		goto fail;
	}
	
	v_array = PyGSL_copy_gslvector_to_pyarray(v);
	if (v_array == NULL){
		line = __LINE__ - 2;
		status = PyGSL_ANY;
		goto fail;
	}

	args = t_params->args;
	Py_XINCREF(args);
	
	FUNC_MESS("\tBEGIN Callback fvv");
	ret = PyObject_CallFunctionObjArgs(callback, x_array, v_array, args, NULL);
	x_array = NULL;
	v_array = NULL;	
	args = NULL;
	FUNC_MESS("\tEND   Callback fvv");

      
	info.callback = callback;
	info.message  = __FUNCTION__;
	info.error_description = NULL;
	info.argnum = 0;
	if(PyGSL_CHECK_PYTHON_RETURN(ret, 2, &info) != GSL_SUCCESS){
		line = __LINE__ - 1;
		status = PyGSL_ANY;
		goto fail;
	}
	info.argnum = 1;


	stat_o = PyTuple_GET_ITEM(ret, 0);
	if (stat_o == NULL){
		line = __LINE__ - 2;
		status = PyGSL_ANY;
		goto fail;
	}

	info.argnum = 1;
	line = __LINE__ + 1;
	flag = PyGSL_pyint_to_int(stat_o, &status, &info);
	/* 
	 * what are the flags that should be returned to to GSL ?
	 * an exception would have returned NULL and would not end up here 
	 */
	switch(flag){		
	case GSL_SUCCESS:
		break;
	default:
		status = flag;
		goto fail;
	}
	
	object = PyTuple_GET_ITEM(ret, 1);
	if (object == NULL){
		line = __LINE__ - 2;
		status = PyGSL_ANY;
		goto fail;
	}

	if(PyGSL_copy_pyarray_to_gslvector(fvv, object, fvv->size, &info) != GSL_SUCCESS){
		line = __LINE__ - 1;
		status = PyGSL_ANY;
		goto fail;
	}     
	if (fvv->size >= 2){
		DEBUG_MESS(2, "fvv[0] = %g, fvv[1] =%g",
			   gsl_vector_get(fvv, 0), gsl_vector_get(fvv, 1));	
	}
	Py_DECREF(ret);
	object = NULL;
	FUNC_MESS_END();
	return status;
	
 fail:
	PyGSL_add_traceback(NULL, __FILE__, __FUNCTION__, line);
	Py_XDECREF(x_array);
	Py_XDECREF(v_array);
	Py_XDECREF(ret);
	return status;
}

static void
pygsl_multifit_nlinear_callback(const size_t iter, void *params,
			       const gsl_multifit_nlinear_workspace *w)
{

	//pygsl_multifit_nlinear_workspace *work_space = NULL;
	pygsl_multifit_nlinear_params *t_params = NULL;
	PyObject *object = NULL, *callback = NULL, *args = NULL,
		*py_work_space = NULL, *iter_obj = NULL;
	int trb_lineno = __LINE__, status = GSL_SUCCESS;
	PyGSL_error_info  info;
	

	FUNC_MESS_BEGIN();

	assert(params != NULL);
	t_params = (pygsl_multifit_nlinear_params *) params;
	//work_space = (pygsl_multifit_nlinear_workspace *) params;

	callback = t_params->callback;
	assert(callback != NULL);
	
	args = t_params->callback_params;
	/* 
	 *  I guess the user interface is more consitent if one calls the 
	 *  callback with args = None rather than having an inconsistent interface.
	 */	  
	if(args == NULL){
		args = Py_None;
	}
	Py_XINCREF(args);
	
	/* also as for args ... keep positional arguments to their spot */
	py_work_space = t_params->self_pyobj;
	if(py_work_space == NULL){
		py_work_space = Py_None;
	}
	assert(py_work_space != NULL);
	Py_INCREF(py_work_space);

	iter_obj = PyLong_FromSize_t(iter);
	if(iter_obj == NULL){
		trb_lineno = __LINE__ - 2;
		status = PyGSL_ANY;
		goto fail;
	}
 	DEBUG_MESS(2, "(status) callback = %p,  py_work_space = %p, args = %p",
		   callback, py_work_space, args);
	
	FUNC_MESS("    Call Python Object BEGIN");
	object = PyObject_CallFunctionObjArgs(callback, py_work_space, iter_obj, args, NULL);
	args = NULL;
	py_work_space = NULL;
	iter_obj = NULL;
	FUNC_MESS("    Call Python Object END");

	info.callback = callback;
	info.message  = __FUNCTION__;
	info.error_description = NULL;
	info.argnum = 0;
	status = PyGSL_CHECK_PYTHON_RETURN(object, 0, &info);
	if(status != GSL_SUCCESS){
		trb_lineno = __LINE__ - 1;
		goto fail;
	}
	Py_XDECREF(object);
	FUNC_MESS_END();
	return;
	
  fail:
	FUNC_MESS("FAIL");
	PyGSL_add_traceback(NULL, __FILE__, __FUNCTION__, trb_lineno);
	Py_XDECREF(args);
	Py_XDECREF(py_work_space);
	Py_XDECREF(iter_obj);
	Py_XDECREF(object);
	DEBUG_MESS(2, "Failed execution of callback at line %d", trb_lineno);
	
	status = (status == GSL_SUCCESS) ? PyGSL_ANY : status;
	if(t_params->buf_is_set){
		longjmp(t_params->env, status);
	}
	return;
	
}

static int
PyGSL_multifit_nlinear_driver(pygsl_multifit_nlinear_workspace *self,
			      const size_t maxiter, const double xtol,
			      const double gtol, const double ftol,
			      PyObject *callback, PyObject *callback_params,
			      int *OUTPUT)
{
	void *callback_ptr = NULL;
	void *callback_params_ptr = NULL;
	int status = GSL_EFAILED, line = __LINE__;

	FUNC_MESS_BEGIN();
	Py_XDECREF(self->params.callback);
	self->params.callback = NULL;
	Py_XDECREF(self->params.callback_params);
	self->params.callback_params = NULL;
	
	DEBUG_MESS(2, "Callback %p", callback);
	if((callback != NULL) && (callback != Py_None)){
		if(PyCallable_Check(callback) == 0){
			DEBUG_MESS(2, "Callback %p not callable!", callback);
			GSL_ERROR("Callback given but not callable!", GSL_EINVAL);
		}
	      
		DEBUG_MESS(2, "Callable callback %p!", callback);
		Py_INCREF(callback);
		self->params.callback = callback;

		Py_XINCREF(callback_params);
		self->params.callback_params = callback_params;
		
		callback_ptr = pygsl_multifit_nlinear_callback;
		callback_params_ptr = &self->params;
	}

	DEBUG_MESS(2, "Callback %p == pygsl_multifit_nlinear_callback: %s", callback_ptr,
		   (pygsl_multifit_nlinear_callback == callback_ptr) ? "True" : "False");

	self->params.buf_is_set = 0;	
	if( (status = setjmp(self->params.env)) == 0){
		self->params.buf_is_set = 1;	
		status = gsl_multifit_nlinear_driver(maxiter, xtol, gtol, ftol,
						     callback_ptr, callback_params_ptr,
						     OUTPUT, self->w);
		self->params.buf_is_set = 0;
		if(status != GSL_SUCCESS){
			line = __LINE__ - 5;
			goto fail;
		}
	} else {
		self->params.buf_is_set = 0;	
		if(status != GSL_SUCCESS){
			line = __LINE__ - 13;
			goto fail;
		}
	}
	Py_XDECREF(self->params.callback);
	self->params.callback = NULL;
	Py_XDECREF(self->params.callback_params);
	self->params.callback_params = NULL;
	FUNC_MESS_END();
	assert(status == GSL_SUCCESS);
	return status;
    
  fail:
	FUNC_MESS("FAIL");
	PyGSL_add_traceback(pygsl_multifit_nlinear_module, __FILE__, __FUNCTION__, line);
	Py_XDECREF(self->params.callback);
	self->params.callback = NULL;
	Py_XDECREF(self->params.callback_params);
	self->params.callback_params = NULL;
	return status;
}
  
static int
pygsl_multifit_nlinear_handle_callbacks(pygsl_multifit_nlinear_workspace *self,
					PyObject * f, PyObject *df, PyObject *fvv,
					PyObject *args)
{
	int status = GSL_SUCCESS;
	/* int line = __LINE__; */

	FUNC_MESS_BEGIN();
    
	Py_XDECREF(self->params.f);
	self->params.f = NULL;
	Py_XDECREF(self->params.df);
	self->params.df = NULL;
	Py_XDECREF(self->params.fvv);
	self->params.fvv = NULL;
	Py_XDECREF(self->params.args);
	self->params.args = NULL;

	self->params.args = args;

	DEBUG_MESS(2, "Checking PyObject f = %p", f);
	if(PyCallable_Check(f) == 0){
		DEBUG_MESS(2, "f %p must be callable", (void *) f);
		GSL_ERROR("Argument f must be callable", GSL_EINVAL);
	}else {
		Py_INCREF(f);
		self->params.f = f;
	}
    
	DEBUG_MESS(2, "Checking PyObject df = %p", df);
	if(PyCallable_Check(df) == 0){
		if(df == NULL || df == Py_None){
			/* derivaties can be computed internally if required */
			self->params.fdf.df = NULL;
		} else {
			DEBUG_MESS(2, "df %p must be callable or PyNone", (void *) df);
			GSL_ERROR("Argument df must be callable", GSL_EINVAL);
		}
	} else {
		Py_INCREF(df);
		self->params.df = df;
		self->params.fdf.df = PyGSL_multifit_nlinear_callback_df;
	}
    
	DEBUG_MESS(2, "Checking PyObject fvv = %p", fvv);
	if(PyCallable_Check(fvv) == 0){
		if(fvv == NULL || fvv == Py_None){
			/* geodesic acceleration is not mandated */
			self->params.fdf.fvv = NULL;
		} else {
			DEBUG_MESS(2, "fvv %p must be callable", (void *) fvv);
			GSL_ERROR("Argument fvv must be callable or None", GSL_EINVAL);
		}
	} else {
		Py_INCREF(fvv);
		self->params.fvv = fvv;
		self->params.fdf.fvv = pygsl_multifit_nlinear_callback_fvv;
	}
    
	FUNC_MESS_END();
	return status;
}

static PyObject *
_pygsl_multifit_nlinear_covar(const gsl_matrix *J, const double epsrel,
			     const PyGSL_array_index_t p)
{
    PyArrayObject * covar_a = NULL;
    PyGSL_array_index_t dimensions[2];
    gsl_matrix_view covar;
    int status = GSL_EFAILED, line = __LINE__;

    dimensions[0] = dimensions[1] = p;
    /* dimensions[1] = p; */
    covar_a = (PyArrayObject *) PyGSL_New_Array(2, dimensions, NPY_DOUBLE);
    if(covar_a == NULL){
      line = __LINE__ - 2;
      goto fail;
    }

    covar = gsl_matrix_view_array((double *) PyArray_DATA(covar_a),
			      PyArray_DIM(covar_a, 0), PyArray_DIM(covar_a, 1));
    status = gsl_multifit_nlinear_covar(J, epsrel, &covar.matrix);
    switch(status){
      case GSL_SUCCESS:
	break;
      default:
	line = __LINE__ - 6;
	goto fail;
    }

    return (PyObject *) covar_a;
    
  fail:    
    PyGSL_add_traceback(pygsl_multifit_nlinear_module, __FILE__, __FUNCTION__, line);
    PyGSL_error_flag(status);
    Py_XDECREF(covar_a);
    return NULL;
}



static PyObject *
pygsl_multifit_nlinear_covar(const gsl_matrix *J, const double epsrel, const long p)
{
	const PyGSL_array_index_t p_a = p;
	return _pygsl_multifit_nlinear_covar(J, epsrel, p_a);
}
/*
 * c-set-style: python
 */
