/* -*- C -*- */
#include "pygsl_multilarge_nlinear.h"
#include <Python.h>

#define PyGSL_OBJECT_CHECK(obj)                   \
	do{                                       \
		if(obj == NULL){                  \
			trb_lineno = __LINE__ -1; \
			goto fail;                \
		}                                 \
	}while(0)

static int
PyMODULEWRAP(callback_df)(CBLAS_TRANSPOSE_t TransJ, const gsl_vector * x,
			  const gsl_vector * u, void * params, gsl_vector * v,
			  gsl_matrix * JTJ)
{

	PyObject *object = NULL, *trans_j_o = NULL, *stat_o = NULL, *obj = NULL,
		*ret = NULL, *callback = NULL, *args = NULL;
	PyArrayObject *x_a = NULL, *u_a = NULL, *v_a = NULL, *JTJ_a = NULL;
	int status = PyGSL_ANY, status2 = PyGSL_ANY, flag = PyGSL_ANY, trb_lineno = __LINE__;
	PyGSL_error_info  info;
  	PyMODULEWRAP(params) *t_params = NULL;

	FUNC_MESS_BEGIN();

	assert(params != NULL);
	t_params = (PyMODULEWRAP(params) *) params;

	callback = t_params->df;
	if(callback == NULL){
		trb_lineno = __LINE__ - 1;
		status =  GSL_ESANITY;
		gsl_error("Function call unexpected. No python callback found",
			  __FILE__, trb_lineno, status);
		goto fail;
	}
	
	/*
	 * use to reference it 
	 * PyArrayObject.base
	 */
	trans_j_o = PyLong_FromLong( (long) TransJ);
	PyGSL_OBJECT_CHECK(trans_j_o);
	x_a = PyGSL_copy_gslvector_to_pyarray(x);
	PyGSL_OBJECT_CHECK(x_a);
	u_a = PyGSL_copy_gslvector_to_pyarray(u);
	PyGSL_OBJECT_CHECK(u_a);
	if(v){
		v_a = PyGSL_copy_gslvector_to_pyarray(v);
		PyGSL_OBJECT_CHECK(v_a);
	} else {
		Py_INCREF(Py_None);
		v_a = (PyArrayObject *) Py_None;
	}
	if(JTJ){
		JTJ_a = PyGSL_copy_gslmatrix_to_pyarray(JTJ);
		PyGSL_OBJECT_CHECK(JTJ_a);
	} else {
		Py_INCREF(Py_None);
		JTJ_a = (PyArrayObject *) Py_None;
	}
	
	args = t_params->args;
	/* Py_XINCREF(args); */
	
	FUNC_MESS_CB_BEGIN();
	ret = PyObject_CallFunctionObjArgs(callback, trans_j_o, x_a, u_a, v_a, JTJ_a, args, NULL);
	FUNC_MESS_CB_END();
	Py_XDECREF(trans_j_o);
	trans_j_o = NULL;
	Py_XDECREF(x_a);
	Py_XDECREF(u_a);
	Py_XDECREF(v_a);
	Py_XDECREF(JTJ_a);
	x_a = u_a = v_a = JTJ_a = NULL;	

	info.callback = callback;
	info.message  = __FUNCTION__;
	info.error_description = NULL;
	info.argnum = 0;
	DEBUG_MESS(2, "Object ret = %p", ret);
	if(PyGSL_CHECK_PYTHON_RETURN(ret, 3, &info) != GSL_SUCCESS){
		trb_lineno = __LINE__ - 1;
		status = PyGSL_ANY;
		goto fail;
	}
	

	status = PyGSL_ANY;
	stat_o = PyTuple_GetItem(ret, 0);
	PyGSL_OBJECT_CHECK(stat_o);
	info.argnum = 1;
	flag = PyGSL_pyint_to_int(stat_o, &status, &info);
	switch(flag){		
	case GSL_SUCCESS:
		status = flag;
		break;
	default:
		status = flag;
		pygsl_error("user func returned error flag", __FILE__, __LINE__, status);
		goto fail;
	}
	
	info.argnum = 2;
	obj = PyTuple_GetItem(ret, 1);
	PyGSL_OBJECT_CHECK(obj);
	if(v){
		status = PyGSL_copy_pyarray_to_gslvector(v, obj, v->size, &info);
		if(status != GSL_SUCCESS){
			trb_lineno = __LINE__ - 2;
			goto fail;
		}
	} else {
		if(obj != Py_None){
			trb_lineno = __LINE__ - 1;
			goto fail;			
		}
	}
	
	info.argnum = 3;
	DEBUG_MESS(2, "Trying to convert JTJ element %d", info.argnum);
	obj = PyTuple_GetItem(ret, 2);
	PyGSL_OBJECT_CHECK(obj);
	DEBUG_MESS(2, "Trying to convert JTJ object %p", obj);
	if(JTJ){
		status = PyGSL_copy_pyarray_to_gslmatrix(JTJ, obj, JTJ->size1,  JTJ->size2, &info);
		if(status != GSL_SUCCESS){
			trb_lineno = __LINE__ - 2;
			goto fail;
		}
	}else{
		if(obj != Py_None){
			trb_lineno = __LINE__ - 1;
			goto fail;			
		}
	}
	Py_DECREF(ret);
	FUNC_MESS_END();
	return status;
	
  fail:
	PyGSL_add_traceback(pygsl_multifit_nlinear_module, __FILE__, __FUNCTION__, trb_lineno);
	FUNC_MESS_FAILED();
	DEBUG_MESS(2, "Failed at line %d", trb_lineno);
	Py_XDECREF(ret);
	Py_XDECREF(trans_j_o);
	Py_XDECREF(x_a);
	Py_XDECREF(u_a);
	Py_XDECREF(v_a);
	Py_XDECREF(JTJ_a);
	Py_XDECREF(ret);
	return status;
}


#include "pygsl_multifit_nlinear_generic.ic"

static PyObject *
pygsl_multilarge_nlinear_covar(gsl_multilarge_nlinear_workspace * w)
{
	PyObject *object = NULL;
	int status = GSL_EFAILED, trb_lineno = __LINE__;
  
	FUNC_MESS_BEGIN();
	status = GSL_ESANITY;
	/* gsl_multilarge_nlinear_covar (gsl_matrix * covar, w); */
	gsl_error("Function covar needs to be implemented", __FILE__, __LINE__, status);
	goto fail;
	FUNC_MESS_END();
	return object;
	
  fail:
	PyGSL_add_traceback(pygsl_multifit_nlinear_module, __FILE__, __FUNCTION__, trb_lineno);
	FUNC_MESS_FAILED();
	Py_XDECREF(object);	
	return NULL;
}

/*
 * c-set-style: python
 */
